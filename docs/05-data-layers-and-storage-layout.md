# Data Layers and Storage Layout (v1)

This project uses a medallion-style architecture (Bronze/Silver/Gold). In Azure Storage, this is implemented using a small set of containers plus strict folder conventions.

---

## 1) Container-to-Layer Mapping

### Bronze = `raw` (immutable as-received)
**Purpose:** Preserve the exact inbound payload for auditability and reprocessing.

**Contains (examples):**
- HL7 v2 ORU messages (original text)
- FHIR Observation resources (original JSON)
- CSV row captures (original files/rows)
- ingestion metadata (source identifiers, timestamps, correlation IDs)

**Rules:**
- Append-only (do not overwrite “history”)
- Store “corrected” re-ingestion as a new object and record the event in `audit`
- No transformations beyond minimal packaging (e.g., wrapping single rows)

---

### Silver = `canonical` (standardized + validated)
**Purpose:** Provide a stable, contract-validated representation of each lab result.

**Contains:**
- Canonical Lab Result Records conforming to:
  - `contracts/canonical/lab_result_record.v1.json`
- Required fields present and validated
- Provenance included (received vs derived + versions)

**Rules:**
- Schema-stable and contract-validated
- Dedup/normalization allowed (as governed), but do not lose traceability to `raw`

---

### Gold = `derived` (curated products)
**Purpose:** Produce consumption-ready datasets for different audiences.

**Contains (subfolders):**
- `derived/semantic/`  
  Harmonized semantic representations (e.g., LOINC-aligned test identity, unit-normalized views, clinically meaningful fields).

- `derived/analytics/`  
  Aggregations and marts for dashboards and reporting (trends, cohorts, longitudinal summaries).

- `derived/ai_ready/`  
  Feature tables and model-ready datasets (time-windowed features, normalized indicators, embeddings if used).

- `derived/agent_outputs/` (optional)  
  Persisted outputs generated by the governance agent (mapping suggestions, drift summaries, review packages).

**Rules:**
- Opinionated and purpose-built
- Safe to query directly
- Must record rules/mapping versions for reproducibility

---

## 2) Cross-Cutting Containers

### `audit` (traceability + governance evidence)
**Purpose:** Store logs and evidence that explain how data moved and changed.

**Contains:**
- ingestion logs and run IDs
- validation errors and rejects (with pointers to raw payloads)
- lineage pointers: raw → canonical → derived
- rule/mapping changes and approvals
- drift detection events (e.g., range shifts, unit changes)

**Rules:**
- Tenant-scoped by default
- Immutable event logs preferred (append-only)

---

### `runbooks` (operational knowledge & runtime artifacts)
**Purpose:** Runtime-accessible governance artifacts (tenant-scoped).

**Contains:**
- mapping catalogs (local test codes → canonical test IDs / LOINC)
- rule bundles and version manifests
- known-issue playbooks used by operations

**Rules:**
- Source-of-truth for docs/code remains GitHub
- `runbooks` stores runtime copies and tenant-scoped operational artifacts

---

## 3) Foldering Convention (Multi-Tenant)

All objects are partitioned by tenant. Container-level isolation is not required, but tenant prefixes are mandatory.

**Template examples:**

Raw:
- `raw/tenants/{tenant_id}/HL7V2_ORU/{source_system_id}/{yyyy}/{mm}/{dd}/{message_id}.hl7`
- `raw/tenants/{tenant_id}/FHIR/{source_system_id}/{yyyy}/{mm}/{dd}/{observation_id}.json`
- `raw/tenants/{tenant_id}/CSV/{source_system_id}/{yyyy}/{mm}/{dd}/{batch_id}.json`

Canonical:
- `canonical/tenants/{tenant_id}/lab_results/{yyyy}/{mm}/{dd}/{result_id}.json`

Derived:
- `derived/tenants/{tenant_id}/semantic/{yyyy}/{mm}/{dd}/...`
- `derived/tenants/{tenant_id}/analytics/{yyyy}/{mm}/{dd}/...`
- `derived/tenants/{tenant_id}/ai_ready/{yyyy}/{mm}/{dd}/...`
- `derived/tenants/{tenant_id}/agent_outputs/{yyyy}/{mm}/{dd}/...`

Audit:
- `audit/tenants/{tenant_id}/events/{yyyy}/{mm}/{dd}/{event_id}.json`

Runbooks:
- `runbooks/tenants/{tenant_id}/mappings/{version}/...`
- `runbooks/tenants/{tenant_id}/rules/{version}/...`

---

## 4) Key Principles

1. **Raw is authoritative for what was received.**
2. **Canonical is authoritative for the standardized shape.**
3. **Derived is authoritative for curated consumption outputs.**
4. **Nothing crosses tenants by default.**
5. **Every derived output must record mapping/rules version for reproducibility.**
6. **No PHI is ever committed to Git; use synthetic data for tests.**
